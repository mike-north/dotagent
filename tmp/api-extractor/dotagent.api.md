## API Report File for "@mnorth/dotagent"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export interface AbstractionMismatch {
    // (undocumented)
    confidence: number;
    // (undocumented)
    declaredType?: AbstractionType;
    // (undocumented)
    detectedType: AbstractionType;
    // (undocumented)
    reasons: string[];
}

// @public (undocumented)
export type AbstractionType = 'skill' | 'subagent' | 'command' | 'rule';

// @public (undocumented)
export interface AbstractionTypeInfo {
    // (undocumented)
    confidence: number;
    // (undocumented)
    indicators: string[];
    // (undocumented)
    type: 'skill' | 'subagent' | 'command' | 'rule';
}

// @public (undocumented)
export class AnalysisError extends SyncError {
    constructor(message: string, target: string, details?: string[]);
    // (undocumented)
    readonly target: string;
}

// @public
export function analyzeMetadata(metadata: RuleMetadata): MetadataAnalysis;

// @public
export function analyzeRuleContent(content: string): ContentAnalysis;

// @public (undocumented)
export type AnyAbstractionMetadata = RuleMetadata | SkillMetadata | SubAgentMetadata | CommandMetadata;

// @public (undocumented)
export abstract class BaseCommand {
    // (undocumented)
    abstract description: string;
    protected error(message: string, options: CommandOptions): void;
    abstract execute(args: string[], options: CommandOptions): Promise<CommandResult>;
    protected failure(message: string, code?: number, data?: unknown): CommandResult;
    protected log(message: string, options: CommandOptions): void;
    // (undocumented)
    abstract name: string;
    protected showHelp(): void;
    protected success(message: string, data?: unknown): CommandResult;
    protected verbose(message: string, options: CommandOptions): void;
}

// @public (undocumented)
export const color: {
    success: (text: string) => string;
    error: (text: string) => string;
    warning: (text: string) => string;
    info: (text: string) => string;
    bold: (text: string) => string;
    dim: (text: string) => string;
    path: (text: string) => string;
    command: (text: string) => string;
    number: (text: string) => string;
    format: (text: string) => string;
    red: (text: string) => string;
    green: (text: string) => string;
    yellow: (text: string) => string;
    blue: (text: string) => string;
    gray: (text: string) => string;
};

// Warning: (ae-forgotten-export) The symbol "colors" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function colorize(text: string, color: keyof typeof colors): string;

// @public (undocumented)
export const COLORS: {
    readonly PRIMARY: "blue";
    readonly SUCCESS: "green";
    readonly WARNING: "yellow";
    readonly ERROR: "red";
    readonly INFO: "cyan";
    readonly MUTED: "gray";
    readonly HIGHLIGHT: "magenta";
};

// @public (undocumented)
export interface CommandMetadata extends RuleMetadata {
    // (undocumented)
    arguments?: Array<{
        name: string;
        type: 'string' | 'number' | 'boolean' | 'file';
        required: boolean;
        description?: string;
    }>;
    // (undocumented)
    trigger: string;
    // (undocumented)
    type: 'command';
    // (undocumented)
    userInvoked: true;
}

// @public
export interface CommandOptions {
    // (undocumented)
    [key: string]: unknown;
    // (undocumented)
    config?: string;
    // (undocumented)
    help?: boolean;
    // (undocumented)
    quiet?: boolean;
    // (undocumented)
    verbose?: boolean;
}

// @public (undocumented)
export class CommandRegistry {
    clear(): void;
    execute(nameOrAlias: string, args: string[], options: CommandOptions): Promise<CommandResult>;
    findSimilar(input: string, maxDistance?: number): string[];
    generateHelp(includeHidden?: boolean): string;
    get(nameOrAlias: string): BaseCommand | undefined;
    getInfo(nameOrAlias: string): {
        name: string;
        description: string;
        aliases: string[];
        category?: string;
        hidden: boolean;
    } | undefined;
    has(nameOrAlias: string): boolean;
    list(includeHidden?: boolean): string[];
    listByCategory(includeHidden?: boolean): Record<string, string[]>;
    register(command: BaseCommand, options?: {
        aliases?: string[];
        category?: string;
        hidden?: boolean;
    }): void;
    unregister(nameOrAlias: string): boolean;
}

// @public (undocumented)
export const commandRegistry: CommandRegistry;

// @public (undocumented)
export interface CommandResult {
    // (undocumented)
    code: number;
    // (undocumented)
    data?: unknown;
    // (undocumented)
    message: string;
}

// @public (undocumented)
export interface ConfigFile {
    // (undocumented)
    content: string;
    // (undocumented)
    detectedIssues?: ValidationError[];
    // (undocumented)
    filePath: string;
    // (undocumented)
    metadata: AnyAbstractionMetadata;
    // (undocumented)
    originalFormat?: string;
    // (undocumented)
    raw?: string;
    // (undocumented)
    ruleCount?: number;
    // (undocumented)
    suggestions?: ValidationSuggestion[];
    // (undocumented)
    type: AbstractionType;
    // (undocumented)
    typeDetection?: AbstractionTypeInfo;
}

// @public (undocumented)
export interface ContentAnalysis {
    // (undocumented)
    commandPatterns: string[];
    // (undocumented)
    keywordDensity: Record<string, number>;
    // (undocumented)
    rulePatterns: string[];
    // (undocumented)
    skillPatterns: string[];
    // (undocumented)
    structuralFeatures: string[];
    // (undocumented)
    subagentPatterns: string[];
}

// @public
export function detectAbstractionType(rule: RuleBlock): AbstractionTypeInfo;

// @public
export function executeCommand(nameOrAlias: string, args: string[], options: CommandOptions): Promise<CommandResult>;

// @public (undocumented)
export function exportAll(rules: RuleBlock[], repoPath: string, dryRun?: boolean, options?: ExportOptions): void;

// @public (undocumented)
export class ExportError extends SyncError {
    constructor(message: string, format: string, details?: string[]);
    // (undocumented)
    readonly format: string;
}

// @public (undocumented)
export interface ExportOptions {
    // (undocumented)
    format?: 'agent' | 'copilot' | 'cursor' | 'cline' | 'windsurf' | 'zed' | 'codex' | 'aider' | 'claude' | 'qodo' | 'gemini' | 'amazonq' | 'roo' | 'junie' | 'opencode';
    // (undocumented)
    includePrivate?: boolean;
    // (undocumented)
    outputPath?: string;
    // (undocumented)
    overwrite?: boolean;
    // (undocumented)
    skipPrivate?: boolean;
}

// @public (undocumented)
export interface ExportResult {
    // (undocumented)
    error?: string;
    // (undocumented)
    filePath: string;
    // (undocumented)
    format: string;
    // (undocumented)
    rulesExported: number;
    // (undocumented)
    success: boolean;
    // (undocumented)
    warnings: string[];
}

// @public (undocumented)
export function exportToAgent(rules: RuleBlock[], outputDir: string, options?: ExportOptions): void;

// @public (undocumented)
export function exportToAider(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void;

// @public (undocumented)
export function exportToAmazonQ(rules: RuleBlock[], outputDir: string, options?: ExportOptions): void;

// @public (undocumented)
export function exportToClaudeCode(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void;

// @public (undocumented)
export function exportToCline(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void;

// @public (undocumented)
export function exportToCodex(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void;

// @public (undocumented)
export function exportToCopilot(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void;

// @public (undocumented)
export function exportToCursor(rules: RuleBlock[], outputDir: string, options?: ExportOptions): void;

// @public (undocumented)
export function exportToGemini(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void;

// @public (undocumented)
export function exportToJunie(rules: RuleBlock[], outputDir: string, options?: ExportOptions): void;

// @public (undocumented)
export function exportToOpenCode(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void;

// @public (undocumented)
export function exportToQodo(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void;

// @public (undocumented)
export function exportToRoo(rules: RuleBlock[], outputDir: string, options?: ExportOptions): void;

// @public (undocumented)
export function exportToWindsurf(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void;

// @public (undocumented)
export function exportToZed(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void;

// @public (undocumented)
export interface FileAnalysis {
    // (undocumented)
    abstractionMismatch?: AbstractionMismatch;
    // (undocumented)
    confidence: number;
    // (undocumented)
    detectedType: AbstractionType;
    // (undocumented)
    filePath: string;
    // (undocumented)
    issues: ValidationError[];
    // (undocumented)
    originalFormat?: string;
    // (undocumented)
    ruleCount?: number;
    // (undocumented)
    suggestions: ValidationSuggestion[];
    // (undocumented)
    warnings: ValidationWarning[];
}

// @public
export function formatBulletList(items: string[], options?: {
    bullet?: string;
    indent?: string;
    style?: 'bullet' | 'number' | 'check';
}): string;

// @public
export function formatCommand(command: string): string;

// @public
export function formatError(message: string, details?: string, hint?: string): string;

// @public
export function formatHeader(text: string, options?: {
    style?: 'box' | 'line' | 'minimal';
    width?: number;
}): string;

// @public
export function formatInfo(message: string, details?: string): string;

// @public (undocumented)
export function formatList(items: string[], prefix?: string): string;

// @public
export function formatNumber(num: number | string): string;

// @public
export function formatPath(path: string): string;

// @public
export function formatSuccess(message: string, details?: string): string;

// @public
export function formatTable(data: Array<Record<string, string>>, options?: {
    headers?: string[];
    maxWidth?: number;
}): string;

// @public
export function formatWarning(message: string, details?: string): string;

// @public (undocumented)
export function header(text: string): string;

// @public (undocumented)
export function importAgent(agentDir: string): ImportResult;

// @public (undocumented)
export function importAider(filePath: string): ImportResult;

// @public (undocumented)
export function importAll(repoPath: string): Promise<ImportResults>;

// @public (undocumented)
export function importAmazonQ(rulesDir: string): ImportResult;

// @public (undocumented)
export function importClaudeCode(filePath: string): ImportResult;

// @public (undocumented)
export function importCline(rulesPath: string): ImportResult;

// @public (undocumented)
export function importCodex(filePath: string): ImportResult;

// @public (undocumented)
export function importCopilot(filePath: string): ImportResult;

// @public (undocumented)
export function importCursor(cursorDir: string): ImportResult;

// @public (undocumented)
export function importCursorLegacy(filePath: string): ImportResult;

// @public (undocumented)
export class ImportError extends SyncError {
    constructor(message: string, filePath: string, details?: string[]);
    // (undocumented)
    readonly filePath: string;
}

// @public (undocumented)
export function importGemini(filePath: string): ImportResult;

// @public (undocumented)
export function importJunie(filePath: string): ImportResult;

// @public (undocumented)
export function importOpenCode(filePath: string): ImportResult;

// @public (undocumented)
export function importQodo(filePath: string): ImportResult;

// @public (undocumented)
export interface ImportResult {
    // (undocumented)
    filePath: string;
    // (undocumented)
    format: 'agent' | 'copilot' | 'cursor' | 'cline' | 'windsurf' | 'zed' | 'codex' | 'aider' | 'claude' | 'qodo' | 'gemini' | 'amazonq' | 'roo' | 'junie' | 'opencode' | 'unknown';
    // (undocumented)
    raw?: string;
    // (undocumented)
    rules: RuleBlock[];
}

// @public (undocumented)
export interface ImportResults {
    // (undocumented)
    errors: Array<{
        file: string;
        error: string;
    }>;
    // (undocumented)
    results: ImportResult[];
}

// @public (undocumented)
export function importRoo(rulesDir: string): ImportResult;

// @public (undocumented)
export function importWindsurf(filePath: string): ImportResult;

// @public (undocumented)
export function importZed(filePath: string): ImportResult;

// @public (undocumented)
export interface MetadataAnalysis {
    // (undocumented)
    confidence: number;
    // (undocumented)
    conflictingSignals: string[];
    // (undocumented)
    explicitType?: AbstractionType;
    // (undocumented)
    typeHints: string[];
}

// @public @deprecated (undocumented)
export function parseAgentMarkdown(markdown: string, options?: ParserOptions): RuleBlock[];

// @public (undocumented)
export function parseFenceEncodedMarkdown(markdown: string, options?: ParserOptions): RuleBlock[];

// @public (undocumented)
export interface ParserOptions {
    // (undocumented)
    preserveWhitespace?: boolean;
    // (undocumented)
    strict?: boolean;
}

// @public
export class ProgressIndicator {
    constructor(total: number, prefix?: string);
    complete(message?: string): void;
    update(current: number, message?: string): void;
}

// @public (undocumented)
export interface ProjectAnalysis {
    // (undocumented)
    files: FileAnalysis[];
    // (undocumented)
    recommendations: ProjectRecommendation[];
    // (undocumented)
    summary: ProjectSummary;
    // (undocumented)
    typeDistribution: TypeDistribution;
}

// @public (undocumented)
export interface ProjectConfig {
    // (undocumented)
    commands: ConfigFile[];
    // (undocumented)
    metadata: ProjectMetadata;
    // (undocumented)
    path: string;
    // (undocumented)
    rules: ConfigFile[];
    // (undocumented)
    skills: ConfigFile[];
    // (undocumented)
    subagents: ConfigFile[];
}

// @public (undocumented)
export interface ProjectMetadata {
    // (undocumented)
    configuration?: SyncConfig;
    // (undocumented)
    detectedTypes: Record<AbstractionType, number>;
    // (undocumented)
    issues: ValidationError[];
    // (undocumented)
    lastAnalyzed: Date;
    // (undocumented)
    name?: string;
    // (undocumented)
    totalFiles: number;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export interface ProjectRecommendation {
    // (undocumented)
    actionable: boolean;
    // (undocumented)
    affectedFiles: string[];
    // (undocumented)
    code: string;
    // (undocumented)
    description: string;
    // (undocumented)
    severity: 'high' | 'medium' | 'low';
    // (undocumented)
    suggestedAction?: string;
    // (undocumented)
    title: string;
}

// @public (undocumented)
export interface ProjectSummary {
    // (undocumented)
    errorCount: number;
    // (undocumented)
    healthScore: number;
    // (undocumented)
    totalCommands: number;
    // (undocumented)
    totalFiles: number;
    // (undocumented)
    totalRules: number;
    // (undocumented)
    totalSkills: number;
    // (undocumented)
    totalSubagents: number;
    // (undocumented)
    warningCount: number;
}

// @public
export function registerCommand(command: BaseCommand, options?: {
    aliases?: string[];
    category?: string;
    hidden?: boolean;
}): void;

// @public (undocumented)
export interface RegisteredCommand {
    // (undocumented)
    aliases?: string[];
    // (undocumented)
    category?: string;
    // (undocumented)
    hidden?: boolean;
    // (undocumented)
    instance: BaseCommand;
}

// @public (undocumented)
export interface RuleBlock {
    // (undocumented)
    content: string;
    // (undocumented)
    metadata: RuleMetadata;
    // (undocumented)
    position?: {
        start: {
            line: number;
            column: number;
        };
        end: {
            line: number;
            column: number;
        };
    };
}

// @public (undocumented)
export interface RuleMetadata {
    // (undocumented)
    [key: string]: unknown;
    // (undocumented)
    alwaysApply?: boolean;
    // (undocumented)
    dependencies?: string[];
    // (undocumented)
    description?: string;
    // (undocumented)
    expertise?: string[];
    // (undocumented)
    globs?: string[];
    // (undocumented)
    id: string;
    // (undocumented)
    manual?: boolean;
    // (undocumented)
    outputs?: string[];
    // (undocumented)
    priority?: 'high' | 'medium' | 'low';
    // (undocumented)
    private?: boolean;
    // (undocumented)
    scope?: string | string[];
    // (undocumented)
    triggers?: string[];
    // (undocumented)
    type?: 'skill' | 'subagent' | 'command' | 'rule';
}

// @public (undocumented)
export interface SkillMetadata extends RuleMetadata {
    // (undocumented)
    autoInvoke?: boolean;
    // (undocumented)
    examples?: string[];
    // (undocumented)
    expertise: string[];
    // (undocumented)
    portability?: 'cross-tool' | 'claude-only';
    // (undocumented)
    type: 'skill';
}

// @public
export class StatusDisplay {
    constructor(message: string);
    fail(message?: string): void;
    start(): void;
    stop(): void;
    succeed(message?: string): void;
    warn(message?: string): void;
}

// @public (undocumented)
export interface SubAgentMetadata extends RuleMetadata {
    // (undocumented)
    isolatedContext: boolean;
    // (undocumented)
    maxTokens?: number;
    // (undocumented)
    model?: 'claude-3-5-sonnet' | 'claude-3-haiku' | 'gpt-4' | 'gpt-3.5-turbo';
    // (undocumented)
    systemPrompt?: string;
    // (undocumented)
    tools?: string[];
    // (undocumented)
    type: 'subagent';
}

// @public (undocumented)
export interface Suggestion {
    // (undocumented)
    actionable: boolean;
    // (undocumented)
    field?: string;
    // (undocumented)
    message: string;
    // (undocumented)
    severity: 'high' | 'medium' | 'low';
    // (undocumented)
    suggestedValue?: string;
    // (undocumented)
    type: 'structure' | 'content' | 'metadata' | 'validation';
}

// @public (undocumented)
export interface SyncConfig {
    // (undocumented)
    autoDetectTypes?: boolean;
    // (undocumented)
    includePrivate?: boolean;
    // (undocumented)
    outputFormats?: string[];
    // (undocumented)
    skipValidation?: boolean;
    // (undocumented)
    strictMode?: boolean;
}

// @public (undocumented)
export class SyncError extends Error {
    constructor(message: string, details: string[], code: string);
    // (undocumented)
    readonly code: string;
    // (undocumented)
    readonly details: string[];
}

// @public (undocumented)
export class SyncManager {
    constructor(config?: SyncConfig);
    // Warning: (ae-forgotten-export) The symbol "ContentAnalysis_2" needs to be exported by the entry point index.d.ts
    analyzeContent(filePath: string): Promise<ContentAnalysis_2>;
    analyzeFile(filePath: string): Promise<FileAnalysis>;
    analyzeProject(projectPath: string): Promise<ProjectAnalysis>;
    // Warning: (ae-forgotten-export) The symbol "CapabilityAnalysis" needs to be exported by the entry point index.d.ts
    analyzeProjectCapabilities(projectPath: string): Promise<CapabilityAnalysis>;
    // Warning: (ae-forgotten-export) The symbol "ComplexityScore" needs to be exported by the entry point index.d.ts
    analyzeProjectComplexity(projectPath: string): Promise<ComplexityScore>;
    // Warning: (ae-forgotten-export) The symbol "AnalysisResult" needs to be exported by the entry point index.d.ts
    analyzeProjectComprehensive(projectPath: string): Promise<AnalysisResult>;
    // Warning: (ae-forgotten-export) The symbol "HealthScore" needs to be exported by the entry point index.d.ts
    analyzeProjectHealth(projectPath: string): Promise<HealthScore>;
    // Warning: (ae-forgotten-export) The symbol "PatternDetection" needs to be exported by the entry point index.d.ts
    detectProjectPatterns(projectPath: string): Promise<PatternDetection>;
    exportFile(config: ConfigFile, format: string): Promise<string>;
    exportProject(config: ProjectConfig, formats: string[]): Promise<ExportResult[]>;
    // Warning: (ae-forgotten-export) The symbol "AbstractionMap" needs to be exported by the entry point index.d.ts
    generateAbstractionMap(projectPath: string): Promise<AbstractionMap>;
    importFile(filePath: string): Promise<ConfigFile>;
    importProject(path: string): Promise<ProjectConfig>;
    // Warning: (ae-forgotten-export) The symbol "RelationshipMap" needs to be exported by the entry point index.d.ts
    mapProjectRelationships(projectPath: string): Promise<RelationshipMap>;
    suggestImprovements(config: ConfigFile): Suggestion[];
    validateConfig(config: ConfigFile): WrapperValidationResult;
}

// @public @deprecated (undocumented)
export function toAgentMarkdown(rules: RuleBlock[]): string;

// @public (undocumented)
export interface TypeDistribution {
    // (undocumented)
    commands: number;
    // (undocumented)
    mixed: number;
    // (undocumented)
    rules: number;
    // (undocumented)
    skills: number;
    // (undocumented)
    subagents: number;
    // (undocumented)
    unknown: number;
}

// @public
export function validateAbstractionGroup(abstractions: Array<{
    metadata: AnyAbstractionMetadata;
    content: string;
}>): ValidationResult;

// @public
export function validateAnyAbstraction(metadata: AnyAbstractionMetadata, content: string): ValidationResult;

// @public
export function validateCommand(metadata: CommandMetadata, content: string): ValidationResult;

// @public
export function validateRule(metadata: RuleMetadata, content: string): ValidationResult;

// @public
export function validateSkill(metadata: SkillMetadata, content: string): ValidationResult;

// @public
export function validateSubAgent(metadata: SubAgentMetadata, content: string): ValidationResult;

// @public (undocumented)
export interface ValidationError {
    // (undocumented)
    code: string;
    // (undocumented)
    field?: string;
    // (undocumented)
    message: string;
    // (undocumented)
    severity: 'error' | 'warning' | 'info';
}

// @public (undocumented)
export interface ValidationResult {
    // (undocumented)
    errors: ValidationError[];
    // (undocumented)
    suggestions: ValidationSuggestion[];
    // (undocumented)
    valid: boolean;
    // (undocumented)
    warnings: ValidationWarning[];
}

// @public (undocumented)
export interface ValidationSuggestion {
    // (undocumented)
    actionable: boolean;
    // (undocumented)
    code: string;
    // (undocumented)
    field?: string;
    // (undocumented)
    message: string;
}

// @public (undocumented)
export interface ValidationWarning {
    // (undocumented)
    code: string;
    // (undocumented)
    field?: string;
    // (undocumented)
    message: string;
    // (undocumented)
    severity: 'error' | 'warning' | 'info';
}

// @public (undocumented)
export class WrapperValidationError extends Error {
    constructor(message: string, issues: ValidationError[]);
    // (undocumented)
    readonly issues: ValidationError[];
}

// @public (undocumented)
export interface WrapperValidationResult {
    // (undocumented)
    errors: ValidationError[];
    // (undocumented)
    suggestions: ValidationSuggestion[];
    // (undocumented)
    valid: boolean;
    // (undocumented)
    warnings: ValidationWarning[];
}

// (No @packageDocumentation comment for this package)

```
